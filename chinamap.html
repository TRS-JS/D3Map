<html>

  <head>
    <meta charset="utf-8">
    <title>中国地图</title></head>
  <style>html, body { padding: 0; margin: 0; width: 100%; height: 100%; overflow: hidden; position: relative; background: #222234; } body > div { position: absolute; overflow: hidden; } #c { left: 0; top: 0; z-index: 1; }


    #s {
        left: 0;
        top: 0;
        z-index: 2;
    }
    .southsea {
        stroke: white;
        stroke-width: 1px;
        fill: #ccc;
      }

      /* This imageless css button was generated by CSSButtonGenerator.com */

    .tooltip {
        padding: .5em;
        background: rgba(88, 116, 147, .8);
        color: rgba(179, 193, 209, 1);
        text-shadow: 0 1px 2px rgba(0, 0, 0, .8);
        border: 1px solid #eee;
        line-height: 1.5em;
        box-shadow: 0 0 8px rgba(0, 0, 0, .5);
        z-index: 999;
        font-family: serif;
        font-size: 11px;

    }
    .degree{
      padding: .5em;
      color: red;
      display: inline-block;
      margin-left: 15px;
      position: relative;
      font-weight: bold;
    }
    .degree:before{
      content: "";
      background: url(http://www.easyicon.net/api/resizeApi.php?id=1075957&size=16);
      height: 16px;
      width: 16px;
      position: absolute;
      left: -10px;
    }
  </style>

  <body>
    <script src="js/d3.min.js"></script>
    <script src="js/queue.v1.js"></script>
    <script src="js/eventUtils.js"></script>
    <script charset="utf-8" src="js/tooltip.js"></script>
   <!--  <script type="text/javascript" src="js/isPointInPolygon.js"></script> -->
 


    <script>
     window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
      var w, h;
      var width = document.body.clientWidth/6*5;
      var height = document.body.clientHeight;
      var div;
      var hoverDistance=10;
      var svg = d3.select("body").append("svg").attr("width", width).attr("height", height).append("g").attr("transform", "translate(0,0)");
      var layer = div = div || d3.select(document.body).append("div").attr("id", "c");

       var projection = d3.geo.mercator().center([107, 40]).scale(750).translate([width / 2, height / 2]);
     
      var color = d3.scale.category20();

      var zoom = d3.behavior.zoom().scaleExtent([.1, 8]).scale(1).translate([0, 0]).on("zoom",
      function() {});

      var canvas = layer.append("canvas").text("This browser don't support element type of Canvas.").attr("id", "mainCanvas").attr("width", width).attr("height", height).call(zoom).node();

      var ctx = canvas.getContext("2d");

      var path = d3.geo.path().projection(projection);
      var path2 = d3.geo.path().projection(projection).context(ctx);

      queue().defer(d3.json,"china.geojson")
             .defer(d3.json,"js/provences.json")
             .defer(d3.json,"js/datachina.json")
             .defer(d3.xml,"js/southchinasea.svg")
             .await(function(error,china,provences,data,southchinasea){
        if (error) return console.error(error);

        //修改data数据 改成随机省内点
        // data = data.map(function(item,index){
        //     item.from =  getRandomPointByPname(item.srcPlace);
        //     item.tp   =  getRandomPointByPname(item.destPlace);
        //   return item;
        // });

        console.log(getRandomPointByPname("河北"));
////

        var values = {};
        var _values = [];
        var x =0;
        for(var i in data){
            var name = data[i].srcPlace;
            var name2 = data[i].destPlace;
            var value = data[i].degree;
            values[name] = value;
            _values.push(value);
            values[name2] = value;
        }
        //求最大值和最小值
        var maxvalue = d3.max(_values, function(d){ return d;});
        var minvalue = 0;
        
        //定义一个线性比例尺，将最小值和最大值之间的值映射到[0, 1]
        var linear = d3.scale.linear()
                        .domain([minvalue, maxvalue])
                        .range([0, 1]);
        //定义最小值和最大值对应的颜色
        var a = d3.rgb(255,255,0);  //浅黄色
        var b = d3.rgb(255,0,0);    //红色
         
        //颜色插值函数
        var computeColor = d3.interpolate(a,b);

        svg.selectAll("path").data(china.features).enter().append("path").attr("stroke", "#000").attr("stroke-width", 1).attr("fill",
        function(d, i) {
            var degree  =  values[d.properties.name]?values[d.properties.name]:0;
            if(degree===0)return "rgba(0,0,0,0)";
            var t = linear(degree);
            var color = computeColor(t);
            return color.toString();
          //return color(i);
        }).attr("d", path);

         svg.html(function(d){
          return d3.select(this).html() + southchinasea.getElementsByTagName("g")[0].outerHTML;
        });

        var gSouthSea = d3.select("#southsea");

        gSouthSea.attr("transform","translate("+(width/6*5)+","+(height/6*5)+") scale(0.5)")
          .attr("class","southsea").attr("fill","yellow").attr("border","1");

        tooltip = tooltip || d3.select(document.body).append("div").attr("class", "tooltip");
        tooltip.style("display", "none");

        var location = svg.selectAll(".location").data(provences).enter().append("g").attr("class", "location").attr("fill", "#fff").attr("transform",
        function(d) {
          var coor = projection([d.longitude, d.latitude]);
          return "translate(" + coor[0] + "," + coor[1] + ")";
        }).append("circle").attr("r", 1);


        function getNodeFromPos(pos){
          var _d = null;
          for (var i = data.length - 1; i >= 0; i--) {
              var d = data[i];
              var from = projection(d.from);
              var to = projection(d.to);
                if(caculateDistance(pos,from)<=hoverDistance||caculateDistance(pos,to)<=hoverDistance){
                  _d = d;break;
                }
          }
          return _d;

        }

        function getNodeFromProcence(pName){
          var _d = null;
          for (var i = data.length - 1; i >= 0; i--) {
              var d = data[i];
                if(d.srcPlace==pName||d.destPlace==pName){
                  _d = d;break;
                }
          }
          return _d;

        }
 
        var tooltip;

    function showToolTip(d) {
        var res;
        if (!d) {
            tooltip.style("display", "none");
            return;
        }
        if (tooltip.style("display") == "none") {
            res = [
                    d.name+"<i class='degree'>"+d.degree+"</i>"
                ];

            tooltip.html(res.join(''));
            tooltip.style("display", "block");
        }
    }

     function moveToolTip(d, event) {
        event = event || d3.event;
        if (d && event) {
            tooltip
                .style("top", event.pageY > height / 2 ? (event.pageY - tooltip.node().clientHeight - 16) + "px" : (event.pageY + 16) + "px")
                .style("left", event.pageX > width / 2 ? (event.pageX - tooltip.node().clientWidth - 16) + "px" : (event.pageX + 16) + "px")
            ;
        }
    }


       function movem(d) {
          var item = arguments.length > 1 && arguments[1] instanceof HTMLCanvasElement ? arguments[1] : this;
          d = null;
          d = getNodeFromPos(d3.mouse(item));
          if (d) {
              d3.select("body").style("cursor", "pointer");
          }else{
              d3.select("body").style("cursor", "default");
          }
          var pName = isPointInChinaPro(d3.mouse(item));
          if(!d){
            d = getNodeFromProcence(pName);
            moveToolTip(d, d3.event);
            showToolTip(d);
          }else{
            moveToolTip(d, d3.event);
            showToolTip(d);
          }
          
        }


        var bufCanvas = document.createElement("canvas");
        bufCanvas.width = width;
        bufCanvas.height = height;

        bufCtx = bufCanvas.getContext("2d");
        bufCtx.globalCompositeOperation = 'lighter';

       layer = d3.select(layer.node().parentNode).append("div").attr("id", "s")
            .append("svg").attr('width', width).attr("height", height);

       layer.append("g")
            //.call(setting.zoom ? setting.zoom : zoom)
            .on('mousemove.tooltip', movem)
            .append("rect")
            .attr("width", width)
            .attr("height", height)
            .attr("x", 0)
            .attr("y", 0)
            .style("fill", "#ffffff")
            .style("fill-opacity", 0);

    var tempFileCanvas,img;
    function getImage(r, g, b, a) {
        if (!img){
           img = new Image();
           img.src = "data:image/png;base64,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";
          }
        if (!tempFileCanvas)
            tempFileCanvas = document.createElement("canvas");

        if (tempFileCanvas.width != img.width)
            tempFileCanvas.width = img.width;

        if (tempFileCanvas.height != img.height)
            tempFileCanvas.height = img.height;

        var imgCtx = tempFileCanvas.getContext("2d"),
                imgData, i;
        imgCtx.drawImage(img, 0, 0);

        imgData = imgCtx.getImageData(0, 0, img.width, img.height);

        i = imgData.data.length;
        while((i -= 4) > -1) {
            imgData.data[i + 3] = imgData.data[i] * a;
            if (imgData.data[i + 3]) {
                imgData.data[i] = r;
                imgData.data[i + 1] = g;
                imgData.data[i + 2] = b;
            }
        }

        imgCtx.putImageData(imgData, 0, 0);
        
        return tempFileCanvas;
    }
　　

    var drawPing = function(context,ping) {

      context.save();
      var point = projection(ping.nowPoint);
      context.drawImage(getImage(ping.color.r,ping.color.g,ping.color.b,1),point[0]-ping.size/2,point[1]-ping.size/2,ping.size,ping.size);
      context.drawImage(getImage(ping.color.r,ping.color.g,ping.color.b,1),point[0]-ping.size/2,point[1]-ping.size/2,ping.size,ping.size);
      
      //context.globalAlpha = ping.globalAlpha;
      //context.arc(point[0],point[1],2.0,Math.PI*2,false);
      //context.fillStyle="white";
      // context.fill();
      context.restore();
      ping.run();
      ping.flash();
    };

    var ping = function(name,color,size,__from,__to,degree,srcPlace,destPlace){
      __from = checkPoint(__from);
      __to = checkPoint(__to);
      this.color=color;
      this.size=size;
      this.from=__from;
      this.to=__to;
      this.nowPoint=this.from;
      this.step=caculateDistance(this.from,this.to)/30;
      this.stepCount=0;
      this.name=name;
      this.degree=degree||0;
      this.steps=[];
      this.distance = caculateDistance(this.from,this.to);
      this.lastFlash = Math.floor(Math.random()*5000)+5;
      this.srcPlace=srcPlace;
      this.destPlace=destPlace;
      
    }



    ping.prototype.end = function(){
      this.step = 0;
    }
    ping.prototype.init = function(){
      this.stepCount = 0;
      //this.step=caculateDistance(this.from,this.to)/10;
      this.nowPoint=[this.from[0],this.from[1]];
     // this.steps=[];
    }

    ping.prototype.flash = function(){

       if(typeof this.flash!="function"){
         return;
       }
       requestAnimationFrame(this.flash);
       this.size*=1.03;
       if(this.size>50){
        this.size=15;
       }
    }

   ping.prototype.drawStep = function(){
     //var bufCtx = ctx;
     bufCtx.lineCap="round";
     bufCtx.lineJoin="round";
     bufCtx.lineWidth = (radius(nr(this)) / 4)  || 1;
     bufCtx.fillStyle = "none";
     bufCtx.strokeStyle = this.color;

     var cura = bufCtx.globalAlpha;

     bufCtx.moveTo(this.from[0],this.from[1]);
     var thatPing = this;

     this.steps.reverse().forEach(function(step,index){

        step[2]*=0.8;
        step[2]=Math.floor(step[2]);
        var point = projection([step[0],step[1]]);
        bufCtx.save();
        bufCtx.beginPath();
        if(index<1){
          var np = projection(thatPing.nowPoint[0],thatPing.nowPoint[1]);
          bufCtx.moveTo(
                 np[0],
                 np[1]);
        }
        else{
          var pnp = projection(thatPing.steps[index-1][0],thatPing.steps[index-1][1]);
          bufCtx.lineTo(
                 pnp[0],
                 pnp[1]);
        }
        bufCtx.lineTo(
                 point[0],
                 point[1]);
        bufCtx.stroke();
        bufCtx.globalAlpha = step[2];
        bufCtx.closePath();
        bufCtx.restore;
     });
     this.steps = this.steps.reverse().filter(function(e){return e[2]>0;});
     bufCtx.globalAlpha = cura;

   }


   ping.prototype.checkAvaiablePoint = function(p1){
     var bx,by;
     if(this.from[0]>=this.to[0]){
       bx = p1[0]>=this.to[0]&&p1[0]<=this.from[0];
     }else{
       bx = p1[0]<=this.to[0]&&p1[0]>=this.from[0];
     }

     if(this.from[1]>=this.to[1]){
       by = p1[1]>=this.to[1]&&p1[1]<=this.from[1];
     }else{
       by = p1[1]<=this.to[1]&&p1[1]>=this.from[1];
     }

     return bx&&by;
   }


    ping.prototype.run = function(){
      if(this.step==0)return;
        this.drawStep();
      //this.step*=0.98;
      

      //if(round(this.nowPoint[0],1)==round(this.to[0],1)||round(this.nowPoint[1],1)==round(this.to[1],1)){
      if(!this.checkAvaiablePoint(this.nowPoint)){
        // this.init();
        //this.stop();
        //console.log("到达终点");
        var that = this;
        if(this.steps.length==0){
          setTimeout(function(){
            // that.nowPoint = that.from;
            that.init();
          },that.lastFlash);
        }
        return;
      }else{
        var step = [this.nowPoint[0],this.nowPoint[1]];
        step.push(100);
        this.steps.push(step);
        this.stepCount++;
        this.nowPoint = caculatePoint(this);
      }


      //console.log("计算位置["+this.name+"],起始["+this.from+"],结束["+this.to+"],目前位置["+this.nowPoint+"],之前位置["+this.lastPoint+"]");
    }
    function nr(d) {
        return d.size > 0 ? d.size : 0;
    }
    function radius(d) {
        return Math.sqrt(d);
    }

    function checkPoint(p){
      if(typeof p[0] == "string"){
        return [Number(p[0]),Number(p[1])];
      }
      return p;
    }

    function round(v,e){
      var t=1;
      for(;e>0;t*=10,e--);
        for(;e<0;t/=10,e++);
          return Math.round(v*t)/t;
    }

    function caculateDistance(p1,p2){
      return Math.sqrt(Math.pow(Math.abs(p1[0]-p2[0]),2)+Math.pow(Math.abs(p1[1]-p2[1]),2))
    }

    function caculate(x,start,end){
      var a,b;
      a = (end[1]-start[1])/(end[0]-start[0]);
      b = (start[1]*end[0]-end[1]*start[0])/(end[0]-start[0]);
      return a*x+b;
    }

    function caculatePoint(ping){
      var point=[],a,b,c;
      a = (ping.to[1]-ping.from[1])/(ping.to[0]-ping.from[0]);
      b = (ping.from[1]*ping.to[0]-ping.to[1]*ping.from[0])/(ping.to[0]-ping.from[0]);
      c = Math.abs(-(b/a));
      b = Math.abs(b);
      if(ping.from[0]>ping.to[0]){
        if(ping.from[1]>ping.to[1]){
           point[0] = ping.nowPoint[0]-ping.step*(c/Math.sqrt(c*c+b*b));
           point[1] = ping.nowPoint[1]-ping.step*(b/Math.sqrt(c*c+b*b));
        }else{
           point[0] = ping.nowPoint[0]-ping.step*(c/Math.sqrt(c*c+b*b));
           point[1] = ping.nowPoint[1]+ping.step*(b/Math.sqrt(c*c+b*b));
        }
      }else{
        if(ping.from[1]>ping.to[1]){
          point[0] = ping.nowPoint[0]+ping.step*(c/Math.sqrt(c*c+b*b));
          point[1] = ping.nowPoint[1]-ping.step*(b/Math.sqrt(c*c+b*b));
        }else{
          point[0] = ping.nowPoint[0]+ping.step*(c/Math.sqrt(c*c+b*b));
          point[1] = ping.nowPoint[1]+ping.step*(b/Math.sqrt(c*c+b*b));
        }

      }
      return point;

    }


    function isPointInChinaPro(point){
      if(!point)return false;
      var allPointsArray = china.features;
      //一次按照省来判断
      for(var i in allPointsArray){
        var provenceObj = allPointsArray[i];
        var allPointsProvence = provenceObj.geometry.coordinates[0];
        // console.log(allPointsProvence);
         if(isPointInPolygon(allPointsProvence,point)){
            //console.log("在"+provenceObj.properties.name+"内部");
            return provenceObj.properties.name;
         }else{
          //console.log("不在"+provenceObj.properties.name+"内部");
         }

        
      }

      return false;
    }


    function getRandomPointByPname(pName){
      var allPointsArray = china.features;
      //一次按照省来判断
      for(var i in allPointsArray){
        var provenceObj = allPointsArray[i];
        if(pName!=provenceObj.properties.name){
          continue;
        }
        var allPointsProvence = provenceObj.geometry.coordinates[0][0];
        var _allPointsProvence = allPointsProvence.map(function(item,index){
            var _item = projection([item[0],item[1]]);
            return _item;
        });
        var maxLongitude =  d3.max(_allPointsProvence,function(d){return d[0];});
        var minLongitude =  d3.min(_allPointsProvence,function(d){return d[0];});
        var maxlatitude =  d3.max(_allPointsProvence,function(d){return d[1];});
        var minLatitude =  d3.min(_allPointsProvence,function(d){return d[1];});
        var count=0,randomPoint;
        while(!randomPoint){
          var randomLongitude = round(getRandomBetween(minLongitude,maxLongitude),2);
          var randomLatitude  = round(getRandomBetween(minLatitude,maxlatitude),2);
          // randomPoint = projection([randomLongitude,randomLatitude]);
          randomPoint = [randomLongitude,randomLatitude];
          if(!isPointInPolygon(allPointsProvence,randomPoint)){
            randomPoint=null;
          }else{
            break;
          }
          count++;
          if(count>=10000){
            break;
          }
        }
          return randomPoint;
      }
    }

    function getRandomBetween(b,c){
       var max,min;
       max = Math.max(b,c);
       min = Math.min(b,c);
       
      
      return Math.random()*(max-min)+min;
    }



    // var demoPing  = new ping("北京",d3.rgb("white"),15,[116.58, 40.18],[113.15,23.08]);
    var demoPing2  = new ping("拉萨",d3.rgb("blue"),15,[91.1, 29.4],[113.15,23.08],155);
    // var demoPing3  = new ping("新疆",d3.rgb("yellow"),15,[91.1, 29.4],[87.36,43.48]);
    // var demoPing4  = new ping("新疆-北京",d3.rgb("red"),15,[91.1, 29.4],[116.58, 40.18]);
    // var demoPing5 =  new ping("aruba",d3.rgb("purple"),15,[-70.0167,12.5167],[15.9614,45.8069]);
    var demoPing7  = new ping("上海",d3.rgb("blue"),15,[111.48,40.49],[113.15,23.08],155);



    data = data.map(function(item,index){
      return new ping(item.name,d3.rgb(color(Math.floor(Math.random()*10000))),15,item.from,item.to,item.degree,item.srcPlace,item.destPlace);
    });
    function redrawCanvas(){
      bufCtx.save();
      bufCtx.clearRect(0, 0, width, height);
      for(var p in data){
        drawPing(bufCtx,data[p]);
      }
      //drawPing(bufCtx,demoPing2);
      // drawPing(bufCtx,demoPing);
      // drawPing(bufCtx,demoPing3);
      // drawPing(bufCtx,demoPing4);
      //drawPing(bufCtx,demoPing5);
      //drawPing(bufCtx,demoPing7);
    }

    var valid = false;
    function render(){
    
     requestAnimationFrame(render);
     ctx.save();
     ctx.clearRect(0,0,width,height);
     redrawCanvas();
     ctx.drawImage(bufCanvas, 0, 0);
     ctx.restore();



    }

    // isPointInChinaPro([112.34,37.52]);

    //setInterval(render,1000);
      render();


      //动态生成一组数据 用于测试效果
      // var datassss = [];
      // var l = provences.location.length;
      // while(datassss.length<20){
      //   var fromData = provences.location[Math.floor(Math.random()*l)],
      //   toData = provences.location[Math.floor(Math.random()*l)];
      //   datassss.push({
      //     name:"测试demo--"+fromData.name+" to "+toData.name,
      //     from:[fromData['longitude'],fromData['latitude']],
      //     to:[toData['longitude'],toData['latitude']],
      //     degree:Math.floor(Math.random()*10000),
      //     srcplace:fromData.province.replace("省",""),
      //     destPlace:toData.province.replace("省","")
      //   });
      // }
      // console.log(JSON.stringify(datassss));
function isPointInPolygon(pts,point){
    
        if(!pts||pts.length<1||!point){
            return false;
        }

        var Point = function(lat,lng){
          this.lng=lng;
          this.lat=lat;
        }

        Point.prototype.equals=function(p){
          return this.lng==p.lng&&this.lat==p.lat;
        }

        pts = pts.map(function(item,index){
            var _item = projection([item[0],item[1]]);
            return new Point(round(_item[0],2),round(_item[1],2));
        });
        var _point = point;//projection([point[0],point[1]]);
        point = new Point(_point[0],_point[1]);

        //var pts = polygon.getPath();//获取多边形点
        
        //下述代码来源：http://paulbourke.net/geometry/insidepoly/，进行了部分修改
        //基本思想是利用射线法，计算射线与多边形各边的交点，如果是偶数，则点在多边形外，否则
        //在多边形内。还会考虑一些特殊情况，如点在多边形顶点上，点在多边形边上等特殊情况。
        
        var N = pts.length;
        var boundOrVertex = true; //如果点位于多边形的顶点或边上，也算做点在多边形内，直接返回true
        var intersectCount = 0;//cross points count of x 
        var precision = 2e-10; //浮点类型计算时候与0比较时候的容差
        var p1, p2;//neighbour bound vertices
        var p = point; //测试点
        
        p1 = pts[0];//left vertex        
        for(var i = 1; i <= N; ++i){//check all rays            
            if(p.equals(p1)){
                return boundOrVertex;//p is an vertex
            }
            
            p2 = pts[i % N];//right vertex            
            if(p.lat < Math.min(p1.lat, p2.lat) || p.lat > Math.max(p1.lat, p2.lat)){//ray is outside of our interests                
                p1 = p2; 
                continue;//next ray left point
            }
            
            if(p.lat > Math.min(p1.lat, p2.lat) && p.lat < Math.max(p1.lat, p2.lat)){//ray is crossing over by the algorithm (common part of)
                if(p.lng <= Math.max(p1.lng, p2.lng)){//x is before of ray                    
                    if(p1.lat == p2.lat && p.lng >= Math.min(p1.lng, p2.lng)){//overlies on a horizontal ray
                        return boundOrVertex;
                    }
                    
                    if(p1.lng == p2.lng){//ray is vertical                        
                        if(p1.lng == p.lng){//overlies on a vertical ray
                            return boundOrVertex;
                        }else{//before ray
                            ++intersectCount;
                        } 
                    }else{//cross point on the left side                        
                        var xinters = (p.lat - p1.lat) * (p2.lng - p1.lng) / (p2.lat - p1.lat) + p1.lng;//cross point of lng                        
                        if(Math.abs(p.lng - xinters) < precision){//overlies on a ray
                            return boundOrVertex;
                        }
                        
                        if(p.lng < xinters){//before ray
                            ++intersectCount;
                        } 
                    }
                }
            }else{//special case when ray is crossing through the vertex                
                if(p.lat == p2.lat && p.lng <= p2.lng){//p crossing over p2                    
                    var p3 = pts[(i+1) % N]; //next vertex                    
                    if(p.lat >= Math.min(p1.lat, p3.lat) && p.lat <= Math.max(p1.lat, p3.lat)){//p.lat lies between p1.lat & p3.lat
                        ++intersectCount;
                    }else{
                        intersectCount += 2;
                    }
                }
            }            
            p1 = p2;//next ray left point
        }
        
        if(intersectCount % 2 == 0){//偶数在多边形外
            return false;
        } else { //奇数在多边形内
            return true;
        } 
}


     });</script>
  </body>

</html>
