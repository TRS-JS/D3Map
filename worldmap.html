<html>

  <head>
    <meta charset="utf-8">
    <title>中国地图</title></head>
  <style>html, body { padding: 0; margin: 0; width: 100%; height: 100%; overflow: hidden; position: relative; background: #222234; } body > div { position: absolute; overflow: hidden; } #c { left: 0; top: 0; z-index: 1; }


    #s {
        left: 0;
        top: 0;
        z-index: 2;
    }
    .southsea {
        stroke: white;
        stroke-width: 1px;
        fill: #ccc;
      }

      /* This imageless css button was generated by CSSButtonGenerator.com */

    .tooltip {
        padding: .5em;
        background: rgba(88, 116, 147, .8);
        color: rgba(179, 193, 209, 1);
        text-shadow: 0 1px 2px rgba(0, 0, 0, .8);
        border: 1px solid #eee;
        line-height: 1.5em;
        box-shadow: 0 0 8px rgba(0, 0, 0, .5);
        z-index: 999;
        font-family: serif;
        font-size: 11px;

    }
    .degree{
      padding: .5em;
      color: red;
      display: inline-block;
      margin-left: 15px;
      position: relative;
      font-weight: bold;
    }
    .degree:before{
      content: "";
      background: url(http://www.easyicon.net/api/resizeApi.php?id=1075957&size=16);
      height: 16px;
      width: 16px;
      position: absolute;
      left: -10px;
    }
  </style>

  <body>
    <script src="js/d3.min.js"></script>
    <script src="js/queue.v1.js"></script>
    <script src="js/eventUtils.js"></script>
    <script charset="utf-8" src="js/tooltip.js"></script>
    <script type="text/javascript" src="js/isPointInPolygon.js"></script>
 


    <script>
     window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
      var w, h;
      var width = document.body.clientWidth/6*5;
      var height = document.body.clientHeight;
      var div;
      var hoverDistance=10;
      var svg = d3.select("body").append("svg").attr("width", width).attr("height", height).append("g").attr("transform", "translate(0,0)");
      var layer = div = div || d3.select(document.body).append("div").attr("id", "c");

      var projection = d3.geo.mercator().scale(180).translate([width / 2, height / 2]);
     
      var color = d3.scale.category20();

      var zoom = d3.behavior.zoom().scaleExtent([.1, 8]).scale(1).translate([0, 0]).on("zoom",
      function() {});

      var canvas = layer.append("canvas").text("This browser don't support element type of Canvas.").attr("id", "mainCanvas").attr("width", width).attr("height", height).call(zoom).node();

      var ctx = canvas.getContext("2d");

      var path = d3.geo.path().projection(projection);
      var path2 = d3.geo.path().projection(projection).context(ctx);

      queue().defer(d3.json,"world-countries.json")
             .defer(d3.json,"js/provences.json")
             .defer(d3.json,"js/data.json")
             .defer(d3.json,"js/capitals.json")
             .await(function(error,china,provences,data,capitals){
        if (error) return console.error(error);


        var values = {};
        var _values = [];
        var x =0;
        for(var i in data){
            var name = data[i].place;
            var value = data[i].degree;
            values[name] = value;
            _values.push(value);
        }
        //求最大值和最小值
        var maxvalue = d3.max(_values, function(d){ return d;});
        var minvalue = 0;
        
        //定义一个线性比例尺，将最小值和最大值之间的值映射到[0, 1]
        var linear = d3.scale.linear()
                        .domain([minvalue, maxvalue])
                        .range([0, 1]);
        //定义最小值和最大值对应的颜色
        var a = d3.rgb(255,255,0);  //浅黄色
        var b = d3.rgb(255,0,0);    //红色
         
        //颜色插值函数
        var computeColor = d3.interpolate(a,b);

        svg.selectAll("path").data(china.features).enter().append("path").attr("stroke", "#000").attr("stroke-width", 1).attr("fill",
        function(d, i) {
            var degree  =  values[d.properties.name]?values[d.properties.name]:0;
            if(degree===0)return "rgba(0,0,0,0)";
            var t = linear(degree);
            var color = computeColor(t);
            return color.toString();
          //return color(i);
        }).attr("d", path);

        tooltip = tooltip || d3.select(document.body).append("div").attr("class", "tooltip");
        tooltip.style("display", "none");

        var location = svg.selectAll(".location").data(capitals.captions).enter().append("g").attr("class", "location").attr("fill", "#fff").attr("transform",
        function(d) {
          var coor = projection([d.longitude, d.latitude]);
          return "translate(" + coor[0] + "," + coor[1] + ")";
        }).append("circle").attr("r", 1);


        function getNodeFromPos(pos){
          for (var i = data.length - 1; i >= 0; i--) {
              var d = data[i];
              var from = projection([d.from[0], d.from[1]]);
              var to = projection([d.to[0], d.to[1]]);
                if(caculateDistance(pos,from)<=hoverDistance||caculateDistance(pos,to)<=hoverDistance)
                  return d;
          }
          return null;

        }
 
        var tooltip;

    function showToolTip(d) {
        var res;
        if (!d) {
            tooltip.style("display", "none");
            return;
        }
        if (tooltip.style("display") == "none") {
            res = [
                    d.name+"<i class='degree'>"+d.degree+"</i>"
                ];

            tooltip.html(res.join(''));
            tooltip.style("display", "block");
        }
    }

     function moveToolTip(d, event) {
        event = event || d3.event;
        if (d && event) {
            tooltip
                .style("top", event.pageY > height / 2 ? (event.pageY - tooltip.node().clientHeight - 16) + "px" : (event.pageY + 16) + "px")
                .style("left", event.pageX > width / 2 ? (event.pageX - tooltip.node().clientWidth - 16) + "px" : (event.pageX + 16) + "px")
            ;
        }
    }


       function movem(d) {
          var item = arguments.length > 1 && arguments[1] instanceof HTMLCanvasElement ? arguments[1] : this;
          d = null;
          d = getNodeFromPos(d3.mouse(item));
          if (d) {
              d3.select("body").style("cursor", "pointer");
          }else{
              d3.select("body").style("cursor", "default");
          }
          moveToolTip(d, d3.event);
          showToolTip(d);
        }


        var bufCanvas = document.createElement("canvas");
        bufCanvas.width = width;
        bufCanvas.height = height;

        bufCtx = bufCanvas.getContext("2d");
        bufCtx.globalCompositeOperation = 'lighter';

       layer = d3.select(layer.node().parentNode).append("div").attr("id", "s")
            .append("svg").attr('width', width).attr("height", height);

       layer.append("g")
            //.call(setting.zoom ? setting.zoom : zoom)
            .on('mousemove.tooltip', movem)
            .append("rect")
            .attr("width", width)
            .attr("height", height)
            .attr("x", 0)
            .attr("y", 0)
            .style("fill", "#ffffff")
            .style("fill-opacity", 0);

    var tempFileCanvas,img;
    function getImage(r, g, b, a) {
        if (!img){
           img = new Image();
           img.src = "data:image/png;base64,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";
          }
        if (!tempFileCanvas)
            tempFileCanvas = document.createElement("canvas");

        if (tempFileCanvas.width != img.width)
            tempFileCanvas.width = img.width;

        if (tempFileCanvas.height != img.height)
            tempFileCanvas.height = img.height;

        var imgCtx = tempFileCanvas.getContext("2d"),
                imgData, i;
        imgCtx.drawImage(img, 0, 0);

        imgData = imgCtx.getImageData(0, 0, img.width, img.height);

        i = imgData.data.length;
        while((i -= 4) > -1) {
            imgData.data[i + 3] = imgData.data[i] * a;
            if (imgData.data[i + 3]) {
                imgData.data[i] = r;
                imgData.data[i + 1] = g;
                imgData.data[i + 2] = b;
            }
        }

        imgCtx.putImageData(imgData, 0, 0);
        
        return tempFileCanvas;
    }
　　

    var drawPing = function(context,ping) {

      context.save();
      var point = projection(ping.nowPoint);
      context.drawImage(getImage(ping.color.r,ping.color.g,ping.color.b,1),point[0]-ping.size/2,point[1]-ping.size/2,ping.size,ping.size);
      //context.globalAlpha = ping.globalAlpha;
      //context.arc(point[0],point[1],2.0,Math.PI*2,false);
      //context.fillStyle="white";
      // context.fill();
      context.restore();
      ping.run();
      ping.flash();
    };

    var ping = function(name,color,size,from,to,degree){
      from = checkPoint(from);
      to = checkPoint(to);
      this.color=color;
      this.size=size;
      this.from=from;
      this.to=to;
      this.nowPoint=from;
      this.step=caculateDistance(this.from,this.to)/25;
      this.stepCount=0;
      this.name=name;
      this.degree=degree||0;
      this.steps=[];
      this.distance = caculateDistance(this.from,this.to);
      this.lastFlash = Math.floor(Math.random()*5000)+3;
      
    }



    ping.prototype.end = function(){
      this.step = 0;
    }
    ping.prototype.init = function(){
      this.stepCount = 0;
      //this.step=caculateDistance(this.from,this.to)/10;
      this.nowPoint=this.from;
     // this.steps=[];
    }

    ping.prototype.flash = function(){

       if(typeof this.flash!="function"){
         return;
       }
       requestAnimationFrame(this.flash);
       this.size*=1.03;
       if(this.size>50){
        this.size=15;
       }
    }

   ping.prototype.drawStep = function(){
     //var bufCtx = ctx;
     bufCtx.lineCap="round";
     bufCtx.lineJoin="round";
     bufCtx.lineWidth = (radius(nr(this)) / 4)  || 1;
     bufCtx.fillStyle = "none";
     bufCtx.strokeStyle = this.color;

     var cura = bufCtx.globalAlpha;

     bufCtx.moveTo(this.from[0],this.from[1]);
     var thatPing = this;

     this.steps.reverse().forEach(function(step,index){

        step[2]*=0.8;
        step[2]=Math.floor(step[2]);
        var point = projection([step[0],step[1]]);
        bufCtx.save();
        bufCtx.beginPath();
        if(index<1){
          var np = projection(thatPing.nowPoint[0],thatPing.nowPoint[1]);
          bufCtx.moveTo(
                 np[0],
                 np[1]);
        }
        else{
          var pnp = projection(thatPing.steps[index-1][0],thatPing.steps[index-1][1]);
          bufCtx.lineTo(
                 pnp[0],
                 pnp[1]);
        }
        bufCtx.lineTo(
                 point[0],
                 point[1]);
        bufCtx.stroke();
        bufCtx.globalAlpha = step[2];
        bufCtx.closePath();
        bufCtx.restore;
     });
     this.steps = this.steps.reverse().filter(function(e){return e[2]>0;});
     bufCtx.globalAlpha = cura;

   }


   ping.prototype.checkAvaiablePoint = function(p1){
     var bx,by;
     if(this.from[0]>=this.to[0]){
       bx = p1[0]>=this.to[0]&&p1[0]<=this.from[0];
     }else{
       bx = p1[0]<=this.to[0]&&p1[0]>=this.from[0];
     }

     if(this.from[1]>=this.to[1]){
       by = p1[1]>=this.to[1]&&p1[1]<=this.from[1];
     }else{
       by = p1[1]<=this.to[1]&&p1[1]>=this.from[1];
     }

     return bx&&by;
   }


    ping.prototype.run = function(){
      if(this.step==0)return;
        this.drawStep();
      //this.step*=0.98;
      

      //if(round(this.nowPoint[0],1)==round(this.to[0],1)||round(this.nowPoint[1],1)==round(this.to[1],1)){
      if(!this.checkAvaiablePoint(this.nowPoint)){
        // this.init();
        //this.stop();
        //console.log("到达终点");
        var that = this;
        if(this.steps.length==0){
          setTimeout(function(){
            // that.nowPoint = that.from;
            that.init();
          },that.lastFlash);
        }
        return;
      }else{
        var step = this.nowPoint;
        step.push(100);
        this.steps.push(step);
        this.stepCount++;
        this.nowPoint = caculatePoint(this);
      }


      //console.log("计算位置["+this.name+"],起始["+this.from+"],结束["+this.to+"],目前位置["+this.nowPoint+"],之前位置["+this.lastPoint+"]");
    }
    function nr(d) {
        return d.size > 0 ? d.size : 0;
    }
    function radius(d) {
        return Math.sqrt(d);
    }

    function checkPoint(p){
      if(typeof p[0] == "string"){
        return [Number(p[0]),Number(p[1])];
      }
      return p;
    }

    function round(v,e){
      var t=1;
      for(;e>0;t*=10,e--);
        for(;e<0;t/=10,e++);
          return Math.round(v*t)/t;
    }

    function caculateDistance(p1,p2){
      return Math.sqrt(Math.pow(Math.abs(p1[0]-p2[0]),2)+Math.pow(Math.abs(p1[1]-p2[1]),2))
    }

    function caculate(x,start,end){
      var a,b;
      a = (end[1]-start[1])/(end[0]-start[0]);
      b = (start[1]*end[0]-end[1]*start[0])/(end[0]-start[0]);
      return a*x+b;
    }

    function caculatePoint(ping){
      var point=[],a,b,c;
      a = (ping.to[1]-ping.from[1])/(ping.to[0]-ping.from[0]);
      b = (ping.from[1]*ping.to[0]-ping.to[1]*ping.from[0])/(ping.to[0]-ping.from[0]);
      c = Math.abs(-(b/a));
      b = Math.abs(b);
      if(ping.from[0]>ping.to[0]){
        if(ping.from[1]>ping.to[1]){
           point[0] = ping.nowPoint[0]-ping.step*(c/Math.sqrt(c*c+b*b));
           point[1] = ping.nowPoint[1]-ping.step*(b/Math.sqrt(c*c+b*b));
        }else{
           point[0] = ping.nowPoint[0]-ping.step*(c/Math.sqrt(c*c+b*b));
           point[1] = ping.nowPoint[1]+ping.step*(b/Math.sqrt(c*c+b*b));
        }
      }else{
        if(ping.from[1]>ping.to[1]){
          point[0] = ping.nowPoint[0]+ping.step*(c/Math.sqrt(c*c+b*b));
          point[1] = ping.nowPoint[1]-ping.step*(b/Math.sqrt(c*c+b*b));
        }else{
          point[0] = ping.nowPoint[0]+ping.step*(c/Math.sqrt(c*c+b*b));
          point[1] = ping.nowPoint[1]+ping.step*(b/Math.sqrt(c*c+b*b));
        }

      }
      return point;

    }

    // var demoPing  = new ping("北京",d3.rgb("white"),15,[116.58, 40.18],[113.15,23.08]);
    var demoPing2  = new ping("拉萨",d3.rgb("blue"),15,[91.1, 29.4],[113.15,23.08],155);
    // var demoPing3  = new ping("新疆",d3.rgb("yellow"),15,[91.1, 29.4],[87.36,43.48]);
    // var demoPing4  = new ping("新疆-北京",d3.rgb("red"),15,[91.1, 29.4],[116.58, 40.18]);
    // var demoPing5 =  new ping("aruba",d3.rgb("purple"),15,[-70.0167,12.5167],[15.9614,45.8069]);



    data = data.map(function(item,index){
      return new ping(item.name,d3.rgb(color(Math.floor(Math.random()*10000))),15,item.from,item.to,item.degree);
    });
    function redrawCanvas(){
      bufCtx.save();
      bufCtx.clearRect(0, 0, width, height);
      for(var p in data){
        drawPing(bufCtx,data[p]);
      }
      //drawPing(bufCtx,demoPing2);
      // drawPing(bufCtx,demoPing);
      // drawPing(bufCtx,demoPing3);
      // drawPing(bufCtx,demoPing4);
      //drawPing(bufCtx,demoPing5);
    }

    var valid = false;
    function render(){
    
     requestAnimationFrame(render);
     ctx.save();
     ctx.clearRect(0,0,width,height);
     redrawCanvas();
     ctx.drawImage(bufCanvas, 0, 0);
     ctx.restore();



    }

    //setInterval(render,1000);
      render();


      //动态生成一组数据 用于测试效果
      // var datassss = [];
      // var l = capitals.captions.length;
      // while(datassss.length<20){
      //   var fromData = capitals.captions[Math.floor(Math.random()*l)],
      //   toData = capitals.captions[Math.floor(Math.random()*l)];
      //   datassss.push({
      //     name:"测试demo--"+fromData.name+" to "+toData.name,
      //     from:[fromData['longitude'],fromData['latitude']],
      //     to:[toData['longitude'],toData['latitude']],
      //     degree:Math.floor(Math.random()*10000),
      //     place:fromData.name
      //   });
      // }
      // console.log(JSON.stringify(datassss));



     });</script>
  </body>

</html>
